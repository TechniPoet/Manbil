vec2 squareComplexNumber(vec2 c)
{
	return vec2((c.x * c.x) - (c.y * c.y),
				2.0	 * c.x * c.y);
}

//Gets the next element in the series given the current number and the starting number.
vec2 getNextElement(vec2 z_n, vec2 z_0)
{
	vec2 z_n_1 = squareComplexNumber(z_n) + z_0;
	return z_n_1;
}


//Return data.
struct LimitData { vec2 finalValue; float iterations; float finalMagnitude; };
bool didLimitDiverge(LimitData lim) { return lim.finalMagnitude >= 2.0; }


//Gets the mandlebrot fractal value at the given position.
LimitData getLimit(vec2 complexNumb, LimitData limit)
{
	limit.iterations = 0.0;
	limit.finalValue = complexNumb;
	for (int i = 0; i < 2000; i++)
	{
		limit.finalValue = getNextElement(limit.finalValue, complexNumb);
		limit.iterations += 1.0;
		limit.finalMagnitude = length(limit.finalValue);
		if (limit.finalMagnitude >= 2.0) break;
	}
	
	return limit;
}





void main(void)
{
	//Keep zooming in and out.
	float time = sin(u_elapsed_seconds) * 1.5 + 2.5;
	float scale = pow(0.0125, time);
	
	//Zoom into the interesting part of the fractal.
	vec2 coord = in_uv_coords * u_resolution * scale;
	coord -= (u_resolution) * scale * 0.5;
	coord.x -= 1.40115;
	coord.y -= 0.0000;
	
	//Get the Mandlebrot fractal value for this pixel/fragment.
	LimitData limit;
	limit = getLimit(coord, limit);
	
	//Convert it into a color.
	float col = (didLimitDiverge(limit) ? mod(limit.iterations, 1.0075) : 0.0);
	float col2 = mod(limit.iterations, 1.0);
	out_color4 = vec4(col, col2, col, 1.0);
}