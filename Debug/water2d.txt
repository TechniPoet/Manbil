//Sunlight data.
const float ambientLightStr = 0.3,
			diffuseLightStr = 0.7;
vec2 lightDir = normalize(vec2(1.0, -1.0));

//TODO: Make the sun cross the sky.

//The base water height if there were no waves.
const float waterHeight = 0.25;
float maxWaterHeight = waterHeight + 0.1255;
	

//Given a position under the water, finds the approximate
// surface position on the water's surface where the beam of light
vec2 getApproximateSurfaceTowardsLight(vec2 pos)
{
	float targetY = waterHeight,
		  t = (maxWaterHeight - pos.y) / lightDir.y;
	
	float offsetX = u_shader_seconds * 1.0;
	return vec2(pos.x + (lightDir.x * t) + offsetX, targetY);
}

//Gets information about the water surface at the given x coordinate.
struct SurfaceData { float height; vec2 normal; float slope; };
SurfaceData getWaterSurface(float xCoord)
{
	
	//Combine multiple sine waves to get an interesting, dynamic wave.
	
	const int waveLevels = 2;
	float waterAmplitudes[waveLevels],
		  waterSpeeds[waveLevels],
		  waterPeriods[waveLevels];
	
	waterAmplitudes[0] = 0.125;
	waterAmplitudes[1] = 0.0025;
	
	waterSpeeds[0] = 1.25;
	waterSpeeds[1] = -0.46875;
	
	waterPeriods[0] = 4.0;
	waterPeriods[1] = 50.0;
	
	
	
	//Sum each wave onto the base height to get the total height.
	//Also sum each wave's derivative to get the slope (for lighting calculations).
	
	float halfA, pX, pS, innerValue;
	
	float height = waterHeight;
	float slope = 0.0;
	
	for (int i = 0; i < waveLevels; ++i)
	{
		halfA = 0.5 * waterAmplitudes[i];
		pX = waterPeriods[i] * xCoord;
		pS = waterPeriods[i] * waterSpeeds[i];
		innerValue = pX + (pS * u_shader_seconds);
		
		height += halfA * sin(innerValue);
		slope += halfA * pS * -cos(innerValue);
	}
	
	
	
	//Output the surface data.
	
	SurfaceData ret;
	
	ret.height = height;
	ret.slope = slope;
	
	float discriminant = 1.0 / ((slope * slope) + 1.0),
		  root = sqrt(discriminant);
	ret.normal = vec2(root, root * slope);
	
	return ret;
}


//Gets the brightness of a surface given its normal.
float getBrightness(vec2 surfaceNormal)
{
	//Brightness is made of three components:
	//"Ambient" light that all surfaces get equally
	//"Diffuse" light based on the angle of the surface and the light
	//"Specular" light based on the angle of the camera to the light.
	//Specular light can't really be simulated with a 2D side-view camera.
	float dot = dot(lightDir, surfaceNormal);
	
	return (clamp(dot, 0.0, 1.0) * diffuseLightStr) + ambientLightStr;
}


void main()
{
	vec2 uv = in_UV;
	uv = vec2(uv.x, 1.0 - uv.y);
	vec2 pixelCoords = vec2(uv.x * u_cam_width, uv.y * u_cam_height);
	
	//Get the water surface data at this X coordinate.
	SurfaceData dat = getWaterSurface(uv.x);
	float watHeight = dat.height;
	
	if (abs(pixelCoords.y - (watHeight * u_cam_height)) < 1.0)
	{
		float b = getBrightness(dat.normal) * 0.15;
		FinalOut_Color = vec4(b, b, b, 1.0);
		return;
	}
	
	//If this pixel is on/below the water, use the water color.
	if (uv.y < watHeight)
	{
		float ratio = uv.y / watHeight;
		const float otherComponentScale = 0.22;
		
		//Find the point roughly on the surface of the water to get the brightness of.
		SurfaceData dat2 = getWaterSurface(getApproximateSurfaceTowardsLight(uv).x);
		float brightness = getBrightness(dat2.normal);
		//Lower the light's brightness as we get closer to the bottom of the water.
		brightness *= pow(uv.y / maxWaterHeight, 0.5);
		
		FinalOut_Color = vec4(vec3(otherComponentScale * ratio,
							   otherComponentScale * ratio,
							   ratio * 1.0) * brightness,
						  1.0);
	}
	//Otherwise, use the sky color.
	else
	{
		FinalOut_Color = vec4(0.6, 0.6, 1.0, 1.0);
	}
}