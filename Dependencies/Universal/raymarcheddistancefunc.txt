//Written by Billy Manning.
//A  ray-marcher using a distance function.
//With help from http://www.geeks3d.com/20130524/building-worlds-with-distance-functions-in-glsl-raymarching-glslhacker-tutorial-opengl/2/






//--------------------------------------------------------------------
//---------------------World geometry----------------------------
//-----------------------------------------------------------------

//Gets the distance from any given position to the surface of a given sphere.
float distanceToSphere(vec3 sphereCenter, float sphereRadius, vec3 outsidePos)
{
	return abs(sphereRadius - distance(sphereCenter, outsidePos));
}
//Gets the distance from any given position to the surface of a given AABB.
float distanceToAABB(vec3 boxCenter, vec3 boxHalfDimensions, vec3 outsidePos)
{
	//Get which face in each direction is closest.
	vec3 faces = sign(outsidePos - boxCenter);
	vec3 faceValues = boxCenter + (faces * boxHalfDimensions);

	vec3 corner1 = boxCenter - boxHalfDimensions,
		 corner2 = boxCenter + boxHalfDimensions;

	//Get the closest point on each face to the outside point.
	vec3 clampedPos = clamp(outsidePos, corner1, corner2);
	vec3 closestPointXZ = vec3(clampedPos.x, faceValues.y, clampedPos.z),
		 closestPointXY = vec3(clampedPos.x, clampedPos.y, faceValues.z),
		 closestPointYZ = vec3(faceValues.x, clampedPos.y, clampedPos.z);

	return min(distance(closestPointXZ, outsidePos),
			   min(distance(closestPointXY, outsidePos),
			       distance(closestPointYZ, outsidePos)));
}
vec3 getAABBNormal(vec3 boxCenter, vec3 boxHalfDimensions, vec3 pos)
{
	//Get which face in each direction is closest.
	vec3 faces = sign(pos - boxCenter);
	vec3 faceValues = boxCenter + (faces * boxHalfDimensions);

	vec3 corner1 = boxCenter - boxHalfDimensions,
		 corner2 = boxCenter + boxHalfDimensions;

	//Get the closest point on each face to the outside point.
	vec3 clampedPos = clamp(pos, corner1, corner2);
	vec3 closestPointXZ = vec3(clampedPos.x, faceValues.y, clampedPos.z),
		 closestPointXY = vec3(clampedPos.x, clampedPos.y, faceValues.z),
		 closestPointYZ = vec3(faceValues.x, clampedPos.y, clampedPos.z);

	float distanceXZ = distance(closestPointXZ, pos),
		  distanceXY = distance(closestPointXY, pos),
		  distanceYZ = distance(closestPointYZ, pos);


	if (distanceXZ < distanceXY)
	{
		if (distanceXZ < distanceYZ)
		{
			return vec3(0.0, faces.y, 0.0);
		}
		return vec3(faces.x, 0.0, 0.0);
	}
	else
	{
		if (distanceXY < distanceYZ)
		{
			return vec3(0.0, 0.0, faces.z);
		}
		return vec3(faces.x, 0.0, 0.0);
	}
}


//Right now, the world geometry is just a sphere, a box, and a floor.
	
vec3 getSpherePos() { return vec3(2.0, 0.0, 0.0); }
float getSphereRadius() { return 1.5; }
float getFloorHeight() { return 0.0; }
vec3 getBoxPos() { return vec3(-4.0, 4.0, 0.0); }
vec3 getBoxHalfDims() { return vec3(1.0, 1.0, 1.0); }

const float SPHERE_FLAG = 0.0,
			BOX_FLAG = 0.5,
			FLOOR_FLAG = 1.0;


//Gets the distance from any given position to the closest surface of the world geometry.
//The X component of the return value is the distance, and the Y component is a flag representing
//    which object in the world is closest to the given position.
vec2 distanceToWorldGeometry(vec3 pos)
{
	float sphereDist = distanceToSphere(getSpherePos(), getSphereRadius(), pos);
	float boxDist = distanceToAABB(getBoxPos(), getBoxHalfDims(), pos);
	float floorDist = abs(pos.y - getFloorHeight());

	if (sphereDist < floorDist)
	{
		if (sphereDist < boxDist)
		{
			return vec2(sphereDist, SPHERE_FLAG);
		}
		
		return vec2(boxDist, BOX_FLAG);
	}
	if (boxDist < floorDist)
	{
		return vec2(boxDist, BOX_FLAG);
	}
	
	return vec2(floorDist, FLOOR_FLAG);
}

const float TILE_ONE = 0.0,
			TILE_TWO = 1.0;
struct TilePosData { float tileObject; vec2 toEdge; float edgeDist; };
//Takes the position along the plane of the floor, and returns data about what tile the position is in.
TilePosData getTileData(vec2 posAlongFloor)
{
	TilePosData ret;

	const vec2 floorTileSpacing = vec2(1.5, 1.5);
	vec2 floorTileSpacing_2 = 2.0 * floorTileSpacing,
		 floorTileSpacing_1_5 = 1.5 * floorTileSpacing,
		 floorTileSpacing_0_5 = 0.5 * floorTileSpacing;

	vec2 floorPos = mod(abs(posAlongFloor), floorTileSpacing_2);


	bool xGreater = (floorPos.x > floorTileSpacing.x),
		 yGreater = (floorPos.y > floorTileSpacing.y);

	if (xGreater)
	{
		ret.toEdge.x = (floorPos.x > floorTileSpacing_1_5.x) ?
						  (floorTileSpacing_2.x - floorPos.x) :
						  (floorPos.x - floorTileSpacing.x);
	}
	else
	{
		ret.toEdge.x = (floorPos.x > floorTileSpacing_0_5.x) ?
						  (floorTileSpacing.x - floorPos.x) :
						  (floorPos.x);
	}
	if (yGreater)
	{
		ret.toEdge.y = (floorPos.y > floorTileSpacing_1_5.y) ?
						  (floorTileSpacing_2.y - floorPos.y) :
						  (floorPos.y - floorTileSpacing.y);
	}
	else
	{
		ret.toEdge.y = (floorPos.y > floorTileSpacing_0_5.y) ?
							(floorTileSpacing.y - floorPos.y) :
							(floorPos.y);
	}

	if ((xGreater && !yGreater) || (!xGreater && yGreater))
	{
		ret.tileObject = TILE_ONE;
	}
	else
	{
		ret.tileObject = TILE_TWO;
	}


	vec2 toEdgeAbs = abs(ret.toEdge);
	ret.edgeDist = (toEdgeAbs.x > toEdgeAbs.y) ? (toEdgeAbs.y / floorTileSpacing.y) : (toEdgeAbs.x / floorTileSpacing.x);


	return ret;
}


const float tileEdgeWidth = 0.1,
			halfTileEdgeWidth = 0.05;

//Gets the surface normal for a position already known to be part of the world geometry.
//The second argument should be the Y component of the return result of "distanceToWorldGeometry()"
vec3 getNormal(vec3 pos, float objectFlag)
{
	//Sphere.
	if (objectFlag == SPHERE_FLAG)
		return normalize(pos - getSpherePos());

	//Box.
	if (objectFlag == BOX_FLAG)
	{
		return getAABBNormal(getBoxPos(), getBoxHalfDims(), pos);

		vec3 boxCenter = getBoxPos(),
			 boxHalfDimensions = getBoxHalfDims();


		//Get which face in each direction is closest.
		vec3 faces = sign(pos - boxCenter);
		vec3 faceValues = boxCenter + (faces * boxHalfDimensions);

		vec3 corner1 = boxCenter - boxHalfDimensions,
			 corner2 = boxCenter + boxHalfDimensions;

		//Get the closest point on each face to the outside point.
		vec3 clampedPos = clamp(pos, corner1, corner2);
		vec3 closestPointXZ = vec3(clampedPos.x, faceValues.y, clampedPos.z),
			 closestPointXY = vec3(clampedPos.x, clampedPos.y, faceValues.z),
			 closestPointYZ = vec3(faceValues.x, clampedPos.y, clampedPos.z);

		float distanceXZ = distance(closestPointXZ, pos),
			  distanceXY = distance(closestPointXY, pos),
			  distanceYZ = distance(closestPointYZ, pos);


		if (distanceXZ < distanceXY)
		{
			if (distanceXZ < distanceYZ)
			{
				return vec3(0.0, faces.y, 0.0);
			}
			return vec3(faces.x, 0.0, 0.0);
		}
		else
		{
			if (distanceXY < distanceYZ)
			{
				return vec3(0.0, 0.0, faces.z);
			}
			return vec3(faces.x, 0.0, 0.0);
		}

		//Normal is pointing straight along one of the axes.
		//GPUs handle branching very badly, to the point where it is usually better
		//     to do some floating-point math instead of branching.
		float smallest = min(distanceXZ, min(distanceXY, distanceYZ));
		vec3 normal = vec3(-0.001 + max(-0.001, smallest - distanceYZ),
						   -0.001 + max(-0.001, smallest - distanceXZ),
						   -0.001 + max(-0.001, smallest - distanceXY));
		return normalize(normal);
	}

	//Floor.
	TilePosData dat = getTileData(pos.xz);
	return vec3(0.0, 1.0, 0.0);

	
	//Add little slants in the spaces between tiles.
	//if (dat.edgeDist > halfTileEdgeWidth) return centerNormal;

	//return smoothstep(normalize(vec3(dat.toEdge.x, 0.0, dat.toEdge.y)),
	//			      vec3(0.0, 1.0, 0.0),
	//			      dat.edgeDist);
}


//Gets the base color for a position already known to be part of the world geometry.
//The second argument should be the Y component of the return result of "distanceToWorldGeometry()"
vec3 getDiffuse(vec3 pos, float objectFlag)
{
	if (objectFlag == SPHERE_FLAG)
		return vec3(1.0, 1.0, 1.0);
		
	if (objectFlag == BOX_FLAG)
		return vec3(0.1, 0.5, 0.8);



	//The object is the floor.

	TilePosData dat = getTileData(pos.xz);

	vec3 col = (dat.tileObject == TILE_ONE) ? vec3(1.0, 0.25, 0.25) : vec3(0.25, 0.25, 1.0);

	if (dat.edgeDist > halfTileEdgeWidth) return col;

	return vec3(0.5, 0.5, 0.5);
}











//----------------------------------------------------------------------
//-------------------------------Lighting--------------------------------
//----------------------------------------------------------------------



//Functions for rotating vectors are needed to make the sun move across the sky.

//Creates a quaternion for rotating vectors around the given axis for the given amount of radians.
vec4 getQuaternion(vec3 axis, float angle)
{
	return vec4(sin(0.5 * angle) * axis,
				cos(0.5 * angle));
}
//Uses a quaternion to rotate a vector.
vec3 rotateVector(vec3 v, vec4 quaternion)
{
	return v + (2.0 * cross(cross(v, quaternion.xyz) + (quaternion.w * v),
							quaternion.xyz));
}


//Uses ambient/diffuse shading, and incorporating a shadow value.

const vec3 baseLightDir = normalize(vec3(1.5, -1.2, 1.0)),
		   lightRotDir = normalize(vec3(1.0, 0.0, -1.0));
const float lightRotSpeed = 0.00;
const float ambientStrength = 0.4,
			diffuseStrength = 0.6,
			specularStrength = 0.5;
const float specularPower = 32.0;

vec3 getLightDir()
{
	vec3 dir = rotateVector(baseLightDir,
							getQuaternion(lightRotDir, lightRotSpeed * u_elapsed_seconds));

	if (dir.y > 0.0) return -dir;
	return dir;
}
			
//The "shadow" value should be from 0 to one -- 0 meaning entirely covered in shadow, and 1 meaning not covered in shadow.
float getBrightness(vec3 surfacePos, vec3 surfaceNormal, float shadow, vec3 lightDir, vec3 rayStart)
{
	float dotted = max(dot(surfaceNormal, -lightDir), 0.0);

	vec3 vertexToEye = normalize(rayStart - surfacePos);
	vec3 lightReflect = normalize(reflect(lightDir, surfaceNormal));

	float specFactor = max(0.0, dot(vertexToEye, lightReflect));
	specFactor = pow(specFactor, specularPower);

	float regularLight = ambientStrength + (diffuseStrength * dotted) + (specularStrength * specFactor);


	//Shadows are bugged; ignore them for now.
	return regularLight;


	//I played around a LOT with figuring out how to combine ambient/diffuse/specular with a shadow value.
	//I'm not sure if this is actually correct, but it looks nice, so I'm using it.
	return regularLight * max(shadow, ambientStrength);
}

//Returns a value between 0 and 1 based on how close this ray is to pointing at the sun.
float getSun(vec3 rayDir, vec3 lightDir)
{
	return smoothstep(0.0, 1.0, pow(0.5 + (0.5 * dot(-lightDir, rayDir)), 128.0));
}








//------------------------------------------------------------------
//--------------------------Fog---------------------------
//-----------------------------------------------------------------

const float fogDropoff = 1.0;
const vec3 fogColor = vec3(0.8, 0.8, 0.8);

float getFog(float distance, float maxPossibleDistance)
{
	return pow((distance / maxPossibleDistance), fogDropoff);
}




	








//--------------------------------------------------------------------
//---------------------Ray-marching algorithm----------------------------
//-----------------------------------------------------------------

const int maxIterations = 300;
const float distanceEpsilon = 0.01;
const float maxDist = 100.0;
	
//Uses the ray-marching algorithm to detect if the given point is in the shadow of something.
float getShadow(vec3 pos, vec3 lightDir)
{
	vec3 posCounter;
	vec2 tempDist;
	float totalDistTraveled = 2.0 * distanceEpsilon;
	float closestDistToObject = 99999.0;
	lightDir = -lightDir; // Travel away from the surface, towards the light.
	
	for (int i = 0; i < maxIterations; ++i)
	{
		posCounter = pos + (lightDir * totalDistTraveled);

		tempDist = distanceToWorldGeometry(posCounter);
		closestDistToObject = min(closestDistToObject, tempDist.x);

		if (tempDist.x <= distanceEpsilon)
		{
			return 0.0;
		}


		totalDistTraveled += tempDist.x;
		if (totalDistTraveled > maxDist) break;
	}

	//No shadow.
	return 1.0;
}

//Calculates the final output color for a surface,
//    accounting for things like lighting and fog.
vec3 getFinalColor(vec3 baseColor, vec3 rayStart, vec3 rayDir, vec3 pos, vec3 surfaceNormal, vec3 lightDir)
{
	return mix(baseColor * getBrightness(pos, surfaceNormal, getShadow(pos, lightDir), lightDir, rayStart),
			   fogColor,
			   getFog(distance(pos.xz, rayStart.xz),
					  dot(rayDir * maxDist,
						  normalize(vec3(pos.x - rayStart.x, 0.0, pos.z - rayStart.z)))));
}

//Finds where the given ray hits using raymarching and returns the resulting color.
//Assumes "rayDir" is normalized.
vec3 marchRay(vec3 rayStart, vec3 rayDir, vec3 camPos)
{
	vec3 posCounter = rayStart;
	vec2 tempDist;
	float totalDistTraveled = 0.0;
	vec3 lightDir = getLightDir();
	
	for (int i = 0; i < maxIterations; ++i)
	{
		posCounter = rayStart + (rayDir * totalDistTraveled);
	
		tempDist = distanceToWorldGeometry(posCounter);

		if (tempDist.x <= distanceEpsilon)
		{
			return getFinalColor(getDiffuse(posCounter, tempDist.y),
								 rayStart, rayDir,
								 posCounter, getNormal(posCounter, tempDist.y),
								 lightDir);
		}
		
		totalDistTraveled += tempDist.x;
		if (totalDistTraveled > maxDist) break;
	}
	
	return fogColor;
}












//--------------------------------------------------------------------
//---------------------Camera data----------------------------
//-----------------------------------------------------------------

struct CameraData { vec3 pos, up, forward, sideways; };
CameraData getCamera()
{
	CameraData dat;

	dat.pos = u_cam_pos + vec3(0.0, 5.0, 0.0);
	dat.forward = u_cam_forward;
	dat.up = u_cam_upward;
	dat.sideways = u_cam_sideways;
	dat.up = normalize(cross(dat.forward, dat.sideways));
	return dat;
}












//--------------------------------------------------------------------
//------------------------Entry point-------------------------------
//-----------------------------------------------------------------

void main(void)
{
	//Map the screen coords to the range (-1, -1) : (1, 1).
	vec2 uv = in_UV;
	uv = vec2(uv.x, -uv.y);
	uv *= 2.0;
	uv -= vec2(1.0, 1.0);
	
	
	
	//Get camera.
	CameraData camDat = getCamera();
	//Figure out the position of this fragment given the uv, cam pos, and cam direction.
	//Scale the y value using the aspect ratio so that the image isn't stretched.
	vec3 fragStart = (camDat.pos + camDat.forward) +
                     (uv.x * camDat.sideways) +
		             (uv.y * camDat.up * u_cam_height / u_cam_width);
	vec3 fragDir = normalize(fragStart - camDat.pos);
	
	
	FinalOutput = vec4(marchRay(fragStart, fragDir, camDat.pos), 1.0);
}