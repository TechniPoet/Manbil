//The "Old One" fractal is rendered with a technique called "distance-field raymarching".

//The idea is that, contrary to normal ray-tracing methods, there is no concrete description of the
//    geometry of the surfaces being ray-marched -- only a "distance function" that can say how far away
//    any given world position is from said geometry. Each ray is stepped forward in variable increments
//    until its distance to the geometry passes below some threshold value, at which point it is
//    considered to have hit the geometry. This method allows for all sorts of interesting effects
//    and optimizations.

//This is just the body of the shader; all the declarations and boilerplate header stuff is generated by
//    the application.

//The inputs to this shader are:
//    vec2 vOut_WorldPos: the world-space coordinates of the fragment.
//    vec3 u_cam_pos: the world-space position of the camera.
//    vec3 u_cam_forward: the world-space forward vector of the camera.
//    vec3 u_cam_upward: the world-space upward vector of the camera.
//    vec3 u_cam_sideways: the world-space sideways vector of the camera.
//    vec3 u_oldOne_pos: the world-space position of the fractal.
//    float u_oldOne_size: the world-space scale of the fractal.

//The output of this shader is:
//   vec4 fOut_Final: the color/alpha of the fractal.


//The threshold distance from world geometry for a position to be considered touching it.
#define DISTANCE_EPSILON 0.01
//The max number of ray march steps to use before assuming the ray doesn't touch the geometry.
#define MAX_ITERATIONS 100

//The number of iterations of the fractal. More iterations means a higher-quality fractal.
#define FRACTAL_ITERATIONS 10


//The distance function gets the distance to a 3D "Mandlebulb" fractal.
//The first component is the distance; the second component is the number of fractal iterations needed.
vec2 distanceFunc(vec3 pos)
{
	pos -= u_oldOne_pos;
	pos /= u_oldOne_size;

	const float bailout = 2.0;
	const float power = 10.0;

	vec3 z = pos;
	float dr = 1.0,
		  r = 0.0,
		  nIterations = 0.0;
	
	for (int i = 0; i < FRACTAL_ITERATIONS; ++i)
	{
		r = length(z);
		nIterations += 1.0;

		if (r > bailout)
		{
			break;
		}

		//Mess around with rotation to change the fractal.
		float theta = acos(z.z / r),
			  phi = atan(z.y, z.x);
		dr = 1.0 + (power * (dr * pow(r, power - 1.0)));
		float zr = pow(r, power);
		theta *= power;
		phi *= power;
		z = zr * vec3(sin(theta) * cos(phi), sin(phi) * sin(theta), cos(theta));
		z += pos;
	}

	return vec2(0.5 * log(r) * r / dr,
		    nIterations / float(FRACTAL_ITERATIONS));
}



//The return value for the ray-marching algorithm.
struct RaymarchData
{
    //The position of the hit.
    vec3 hitPos;
    //The number of iterations needed to hit the surface, from 0 (hit it right away) to 1 (didn't hit it).
    float nIterations;
    //The number of iterations of the fractal at the hit pos.
    float nFractalIterations;
};

//The ray-marching algorithm.
void marchRay(vec3 rayStart, vec3 rayDir, out RaymarchData outData)
{
	//Initialize the counters.
	outData.hitPos = rayStart;
	outData.nIterations = 0.0;
	vec2 tempDist;

	//Step the ray forward.
	for (int i = 0; i < MAX_ITERATIONS; ++i)
	{
		tempDist = distanceFunc(outData.hitPos);

		//If the distance to the surface is small enough, count it as a collision.
		if (tempDist.x < DISTANCE_EPSILON)
		{
			outData.nIterations /= float(MAX_ITERATIONS);
			outData.nFractalIterations = tempDist.y;
			return;
		}

		//Otherwise, march the ray forward and try again.
		//Note that we can step the ray forward by "tempDist"
		//    and be guaranteed to not skip over any surfaces.
		outData.nIterations += 1.0;
		outData.hitPos += rayDir * tempDist.x;
	}

	outData.nFractalIterations = 1.0;
	outData.nIterations = 1.0;
}


void main()
{
	//The ray starts at the fragment position and points away from the camera.
	vec3 rayStart = vOut_WorldPos,
	     rayDir = rayStart - u_cam_pos;

	//Do the ray-marching and see what was hit.
	RaymarchData dat;
	marchRay(rayStart, rayDir, dat);


	//Color the result.
	//Note that the material's blending mode is opaque, but it has an alpha test that discards
	//    fragments with an alpha of 0.0.
	float outAlpha = 1.0 - dat.nIterations;
	fOut_Final = vec4(pow(vec3(dat.nFractalIterations), vec3(2.0)), outAlpha);


	//These are some debug color outputs that were useful during testing; feel free to uncomment one to
	//    see what it does.
	//fOut_Final = vec4(1.0, 1.0, 1.0, 1.0);
	//fOut_Final = vec4(vec3(dat.nIterations), outAlpha);
}