//The "Old One" fractal is rendered with a technique called "distance-field raymarching".

//The idea is that, contrary to normal ray-tracing methods, there is no concrete description of the
//    geometry of the surfaces being ray-marched -- only a "distance-field function" that can say
//    how far away any given world position is from said geometry. Each ray is stepped forward in
//    variable increments until its distance to the geometry passes below some threshold value,
//    at which point it is considered to have hit the geometry. This method allows for all sorts of
//    interesting effects and optimizations, including 3D fractal rendering in real-time.

//This is just the body of the fragment shader; all the declarations, inputs, and boilerplate header
//    stuff is generated by the application.

//The inputs to this shader are:
//    vec2 vOut_WorldPos: the world-space coordinates of the fragment.
//    vec3 u_cam_pos: the world-space position of the camera.
//    vec3 u_cam_forward: the world-space forward vector of the camera.
//    vec3 u_cam_upward: the world-space upward vector of the camera.
//    vec3 u_cam_sideways: the world-space sideways vector of the camera.
//    vec3 u_oldOne_pos: the world-space position of the fractal.
//    float u_oldOne_size: the world-space scale of the fractal.
//	  float u_oldOne_power: the power of the fractal. Affects its shape.
//	  vec3 u_oldOne_color1: the first color of the fractal.
//	  vec3 u_oldOne_color2: the second color of the fractal.
//	  float u_oldOne_roundness: the roundness of the fractal's base.
//	  float u_oldOne_spikyLeft: the spikyness of one side of the fractal.
//	  float u_oldOne_spikyRight: the spikyness of another side of the fractal.
//	  float u_oldOne_angriness: the anger level of the fractal, from 0 to 1.
//	  mat4 u_matVP: the ViewProjection matrix (converts from world space to screen space).
//	  int FRACTAL_ITERATIONS: the number of iterations to use for the fractal distance field estimator.

//The output of this shader is:
//   vec4 fOut_Final: the color/alpha of the fractal. Note that the fractal is rendered using opaque
//                    blending, but an alpha of 0 will result in that pixel being discarded (so that it
//					  doesn't block anything behind it).


//The threshold distance from world geometry for a position to be considered touching it.
#define DISTANCE_EPSILON 0.001
//The max number of ray march steps to use before assuming the ray doesn't touch the geometry.
#define MAX_ITERATIONS 300


//The distance function gets the distance to a 3D "Mandlebulb" fractal.
//The first component is the distance; the second component is the number of fractal iterations needed.
vec2 distanceFunc(vec3 pos)
{
	pos -= u_oldOne_pos;
	pos /= u_oldOne_size;

	const float bailout = 2.0;

	vec3 z = pos;
	float dr = 1.0,
		  r = 0.0,
		  nIterations = 0.0;
	
	for (int i = 0; i < FRACTAL_ITERATIONS; ++i)
	{
		r = length(z);
		nIterations += 1.0;

		if (r > bailout)
		{
			break;
		}

		//Mess around with rotation to change the fractal.
		float theta = acos(z.z / r),
			  phi = atan(z.y, z.x);
		dr = 1.0 + (u_oldOne_power * (dr * pow(r, u_oldOne_power - 1.0)));
		float zr = pow(r, u_oldOne_power);
		theta *= u_oldOne_power;
		phi *= u_oldOne_power;
		z = zr * vec3(sin(theta) * cos(phi),
					  clamp(sin(phi) * sin(theta),
							u_oldOne_spikyLeft * (1.0 - u_oldOne_angriness + 0.001),
							u_oldOne_spikyRight * (1.0 - u_oldOne_angriness + 0.001)),
					  cos(theta));
		z += pow(pos, vec3(1.0));
	}

	return vec2(0.5 * log(r) * r / dr,
		        nIterations / float(FRACTAL_ITERATIONS));
}



//The return value for the ray-marching algorithm.
struct RaymarchData
{
    //The position of the hit.
    vec3 hitPos;
    //The number of iterations needed to hit the surface, from 0 (hit it right away) to 1 (didn't hit it).
    float nIterations;
    //The number of iterations of the fractal at the hit pos.
    float nFractalIterations;
};

//The ray-marching algorithm.
void marchRay(vec3 rayStart, vec3 rayDir, out RaymarchData outData)
{
	//Initialize the counters.
	outData.hitPos = rayStart;
	outData.nIterations = 0.0;
	vec2 tempDist;

	//Step the ray forward.
	for (int i = 0; i < MAX_ITERATIONS; ++i)
	{
		tempDist = distanceFunc(outData.hitPos);

		//If the distance to the surface is small enough, count it as a collision.
		if (tempDist.x < DISTANCE_EPSILON)
		{
			outData.nIterations /= float(MAX_ITERATIONS);
			outData.nFractalIterations = tempDist.y;
			return;
		}

		//Otherwise, march the ray forward and try again.
		//Note that we can step the ray forward by "tempDist"
		//    and be guaranteed to not skip over any surfaces.
		outData.nIterations += 1.0;
		outData.hitPos += rayDir * tempDist.x;
	}

	outData.nFractalIterations = 1.0;
	outData.nIterations = 1.0;
}


void main()
{
	//March the ray forward from the start position.
	//The ray starts at the fragment position.
	//The ray points in the same direction as the camera.
	//Notice that because all rays point in the same direction, this is an orthographic projection on
	//    the fractal, not the usual perspective projection (which would be "rayStart - camPos").
	//I am not sure why it works so much better with ortho.
	RaymarchData dat;
	marchRay(vOut_WorldPos, u_cam_forward, dat);


	//Color the result.
	//Note that the material's blending mode is opaque, but it has an alpha test that discards
	//    fragments with an alpha of 0.0.
	float outAlpha = 1.0 - dat.nIterations;
	fOut_Final = vec4(mix(u_oldOne_color1, u_oldOne_color2,
					      pow(vec3(dat.nIterations), vec3(0.55))),
					  outAlpha);

	//Write out the depth of the fractal at the given pos.
	//The calculated depth is from -1 to 1, but the output depth must be from 0 to 1.
	vec4 screenPos = u_matVP * vec4(dat.hitPos, 1.0);
	gl_FragDepth = 0.5 + (0.5 * (screenPos.z / screenPos.w));

	//These are some debug color outputs that were useful during testing; feel free to uncomment one to
	//    see what it does.
	//fOut_Final *= 0.001;
	//fOut_Final += vec4(0.0, 1.0, 1.0, 1.0);
	//fOut_Final += vec4(vec3(dat.nIterations), outAlpha);
}