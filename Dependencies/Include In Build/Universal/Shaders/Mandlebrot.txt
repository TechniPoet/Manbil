//Mandlebrot

//Displays the standard Mandlebrot fractal.
//The camera constantly zooms in and out over and over.


#define ITERATIONS 2000


vec2 squareComplexNumber(vec2 c)
{
	return vec2((c.x * c.x) - (c.y * c.y),
				2.0	 * c.x * c.y);
}

//Gets the next element in the series given the current number and the starting number.
vec2 getNextElement(vec2 z_n, vec2 z_0)
{
	vec2 z_n_1 = squareComplexNumber(z_n) + z_0;
	return z_n_1;
}


//Data returned by the Mandlebrot algorithm.
//Used to color the pixel.
struct LimitData
{
	vec2 finalValue;
	float iterations;
	float finalMagnitude;
};

bool didLimitDiverge(LimitData lim) { return lim.finalMagnitude >= 2.0; }


//Gets the Mandlebrot fractal value at the given position.
LimitData getLimit(vec2 complexNumb, LimitData limit)
{
	limit.iterations = 0.0;
	limit.finalValue = complexNumb;
	for (int i = 0; i < ITERATIONS; i++)
	{
		limit.finalValue = getNextElement(limit.finalValue, complexNumb);
		limit.iterations += 1.0;
		limit.finalMagnitude = length(limit.finalValue);
		if (limit.finalMagnitude >= 2.0)
            break;
	}
	
	return limit;
}



void main(void)
{
	//Keep zooming in and out.
	float time = sin(u_shader_seconds) * 1.5 + 2.5;
	float scale = pow(0.0125, time);
	
	//Zoom into the interesting part of the fractal.
	vec2 resolution = vec2(u_cam_width, u_cam_height);
	vec2 coord = vec2(in_UV.x, in_UV.y) * resolution * scale;
	coord -= resolution * scale * 0.5;
	coord.x -= 1.40115;
	
	//Get the Mandlebrot fractal value for this pixel/fragment.
	LimitData limit;
	limit = getLimit(coord, limit);
	
	//Convert it into a color.
	float col = (didLimitDiverge(limit) ? mod(limit.iterations, 1.0075) : 0.0);
	float col2 = mod(limit.iterations, 1.0);
	out_FinalColor = vec4(col2, col, col, 1.0);
}