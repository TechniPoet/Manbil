//Written by Billy Manning.
//A ray-marcher using a distance function.
//With help from http://www.geeks3d.com/20130524/building-worlds-with-distance-functions-in-glsl-raymarching-glslhacker-tutorial-opengl/2/






//--------------------------------------------------------------------
//---------------------World geometry----------------------------
//-----------------------------------------------------------------

//Gets the distance from any given position to the surface of a given sphere.
float distanceToSphere(vec3 sphereCenter, float sphereRadius, vec3 outsidePos)
{
	return abs(sphereRadius - distance(sphereCenter, outsidePos));
}
vec3 getSphereNormal(vec3 sphereCenter, float sphereRadius, vec3 pos)
{
	return normalize(pos - sphereCenter);
}


//Gets the distance from any given position to the surface of a given AABB.
float distanceToAABB(vec3 boxCenter, vec3 boxHalfDimensions, vec3 outsidePos)
{
	//Get which face in each direction is closest.
	vec3 faces = sign(outsidePos - boxCenter);
	vec3 faceValues = boxCenter + (faces * boxHalfDimensions);

	vec3 corner1 = boxCenter - boxHalfDimensions,
		 corner2 = boxCenter + boxHalfDimensions;

	//Get the closest point on each face to the outside point.
	vec3 clampedPos = clamp(outsidePos, corner1, corner2);
	vec3 closestPointXZ = vec3(clampedPos.x, faceValues.y, clampedPos.z),
		 closestPointXY = vec3(clampedPos.x, clampedPos.y, faceValues.z),
		 closestPointYZ = vec3(faceValues.x, clampedPos.y, clampedPos.z);

	return min(distance(closestPointXZ, outsidePos),
			   min(distance(closestPointXY, outsidePos),
			       distance(closestPointYZ, outsidePos)));
}
vec3 getAABBNormal(vec3 boxCenter, vec3 boxHalfDimensions, vec3 pos)
{
	//Get which face in each direction is closest.
	vec3 faces = sign(pos - boxCenter);
	vec3 faceValues = boxCenter + (faces * boxHalfDimensions);

	vec3 corner1 = boxCenter - boxHalfDimensions,
		 corner2 = boxCenter + boxHalfDimensions;

	//Get the closest point on each face to the outside point.
	vec3 clampedPos = clamp(pos, corner1, corner2);
	vec3 closestPointXZ = vec3(clampedPos.x, faceValues.y, clampedPos.z),
		 closestPointXY = vec3(clampedPos.x, clampedPos.y, faceValues.z),
		 closestPointYZ = vec3(faceValues.x, clampedPos.y, clampedPos.z);

	float distanceXZ = distance(closestPointXZ, pos),
		  distanceXY = distance(closestPointXY, pos),
		  distanceYZ = distance(closestPointYZ, pos);


	if (distanceXZ < distanceXY)
	{
		if (distanceXZ < distanceYZ)
		{
			return vec3(0.0, faces.y, 0.0);
		}
		return vec3(faces.x, 0.0, 0.0);
	}
	else
	{
		if (distanceXY < distanceYZ)
		{
			return vec3(0.0, 0.0, faces.z);
		}
		return vec3(faces.x, 0.0, 0.0);
	}
}


vec3 modPos(vec3 pos)
{
	return vec3(mod(abs(pos.x), 10.0),
			    pos.y, pos.z);


	return mod(abs(pos), 10.0);
}

//Gets the distance from any given position to the closest surface of the world geometry.
//The X component of the return value is the distance, and the Y component is a flag representing
//    which object in the world is closest to the given position.
vec2 distanceToWorldGeometry(vec3 pos)
{
	pos = modPos(pos);
	return vec2(distanceToAABB(vec3(4.5, 0.0, 0.0), vec3(3.0), pos), 1);
}

//Gets the surface normal for a position already known to be part of the world geometry.
//The second argument should be the Y component of the return result of "distanceToWorldGeometry()"
vec3 getNormal(vec3 pos, float objectFlag)
{
	const vec2 sampleEpsilon = vec2(0.001, 0.0);

	float xNeg = distanceToWorldGeometry(pos - sampleEpsilon.xyy).x,
	      xPos = distanceToWorldGeometry(pos + sampleEpsilon.xyy).x,
		  yNeg = distanceToWorldGeometry(pos - sampleEpsilon.yxy).x,
	      yPos = distanceToWorldGeometry(pos + sampleEpsilon.yxy).x,
		  zNeg = distanceToWorldGeometry(pos - sampleEpsilon.yyx).x,
	      zPos = distanceToWorldGeometry(pos + sampleEpsilon.yyx).x;

	vec3 ret = sampleEpsilon.yyy;
	if (xNeg > xPos)
	{
		ret.x = -xNeg;
	}
	else
	{
		ret.x = xPos;
	}
	if (yNeg > yPos)
	{
		ret.y = -yNeg;
	}
	else
	{
		ret.y = yPos;
	}
	if (zNeg > zPos)
	{
		ret.z = -zNeg;
	}
	else
	{
		ret.z = zPos;
	}

	return normalize(ret);




		  

	pos = modPos(pos);
	return getAABBNormal(vec3(4.5, 0.0, 0.0), vec3(3.0), pos);
}


//Gets the base color for a position already known to be part of the world geometry.
//The second argument should be the Y component of the return result of "distanceToWorldGeometry()"
vec3 getDiffuse(vec3 pos, float objectFlag)
{
	if (pos.x > 0.0) return vec3(0.0, 1.0, 0.0);
	else return vec3(0.0, 0.0, 1.0);
}











//----------------------------------------------------------------------
//-------------------------------Lighting--------------------------------
//----------------------------------------------------------------------



//Functions for rotating vectors are needed to make the sun move across the sky.

//Creates a quaternion for rotating vectors around the given axis for the given amount of radians.
vec4 getQuaternion(vec3 axis, float angle)
{
	return vec4(sin(0.5 * angle) * axis,
				cos(0.5 * angle));
}
//Uses a quaternion to rotate a vector.
vec3 rotateVector(vec3 v, vec4 quaternion)
{
	return v + (2.0 * cross(cross(v, quaternion.xyz) + (quaternion.w * v),
							quaternion.xyz));
}


//Uses ambient/diffuse shading, and incorporating a shadow value.

const vec3 baseLightDir = normalize(vec3(1.5, -1.2, 1.0)),
		   lightRotDir = normalize(vec3(1.0, 0.0, -1.0));
const float lightRotSpeed = 0.00;
const float ambientStrength = 0.4,
			diffuseStrength = 0.6,
			specularStrength = 0.5;
const float specularPower = 32.0;

vec3 getLightDir()
{
	vec3 dir = rotateVector(baseLightDir,
							getQuaternion(lightRotDir, lightRotSpeed * u_elapsed_seconds));

	if (dir.y > 0.0) return -dir;
	return dir;
}
			
//The "shadow" value should be from 0 to one -- 0 meaning entirely covered in shadow, and 1 meaning not covered in shadow.
float getBrightness(vec3 surfacePos, vec3 surfaceNormal, float shadow, vec3 lightDir, vec3 rayStart)
{
	float dotted = max(dot(surfaceNormal, -lightDir), 0.0);

	vec3 vertexToEye = normalize(rayStart - surfacePos);
	vec3 lightReflect = normalize(reflect(lightDir, surfaceNormal));

	float specFactor = max(0.0, dot(vertexToEye, lightReflect));
	specFactor = pow(specFactor, specularPower);

	float regularLight = ambientStrength + (diffuseStrength * dotted) + (specularStrength * specFactor);


	//Shadows are bugged; ignore them for now.
	return regularLight;


	//I played around a LOT with figuring out how to combine ambient/diffuse/specular with a shadow value.
	//I'm not sure if this is actually correct, but it looks nice, so I'm using it.
	return regularLight * max(shadow, ambientStrength);
}

//Returns a value between 0 and 1 based on how close this ray is to pointing at the sun.
float getSun(vec3 rayDir, vec3 lightDir)
{
	return smoothstep(0.0, 1.0, pow(0.5 + (0.5 * dot(-lightDir, rayDir)), 128.0));
}








//------------------------------------------------------------------
//--------------------------Fog---------------------------
//-----------------------------------------------------------------

const float fogDropoff = 1.0;
const vec3 fogColor = vec3(0.8, 0.8, 0.8);

float getFog(float distance, float maxPossibleDistance)
{
	return pow((distance / maxPossibleDistance), fogDropoff);
}




	








//--------------------------------------------------------------------
//---------------------Ray-marching algorithm----------------------------
//-----------------------------------------------------------------

const int maxIterations = 300;
const float distanceEpsilon = 0.01;
const float maxDist = 100.0;
	
//Uses the ray-marching algorithm to detect if the given point is in the shadow of something.
float getShadow(vec3 pos, vec3 lightDir)
{
	vec3 posCounter;
	vec2 tempDist;
	float totalDistTraveled = 2.0 * distanceEpsilon;
	float closestDistToObject = 99999.0;
	lightDir = -lightDir; // Travel away from the surface, towards the light.
	
	for (int i = 0; i < maxIterations; ++i)
	{
		posCounter = pos + (lightDir * totalDistTraveled);

		tempDist = distanceToWorldGeometry(posCounter);
		closestDistToObject = min(closestDistToObject, tempDist.x);

		if (tempDist.x <= distanceEpsilon)
		{
			return 0.0;
		}


		totalDistTraveled += tempDist.x;
		if (totalDistTraveled > maxDist) break;
	}

	//No shadow.
	return 1.0;
}

//Calculates the final output color for a surface,
//    accounting for things like lighting and fog.
vec3 getFinalColor(vec3 baseColor, vec3 rayStart, vec3 rayDir, vec3 pos, vec3 surfaceNormal, vec3 lightDir)
{
	return mix(baseColor * getBrightness(pos, surfaceNormal, getShadow(pos, lightDir), lightDir, rayStart),
			   fogColor,
			   getFog(distance(pos.xz, rayStart.xz),
					  dot(rayDir * maxDist,
						  normalize(vec3(pos.x - rayStart.x, 0.0, pos.z - rayStart.z)))));
}

//Finds where the given ray hits using raymarching and returns the resulting color.
//Assumes "rayDir" is normalized.
vec3 marchRay(vec3 rayStart, vec3 rayDir, vec3 camPos)
{
	vec3 posCounter = rayStart;
	vec2 tempDist;
	float totalDistTraveled = 0.0;
	vec3 lightDir = getLightDir();
	
	for (int i = 0; i < maxIterations; ++i)
	{
		posCounter = rayStart + (rayDir * (totalDistTraveled - (2.0 * distanceEpsilon)));
	
		tempDist = distanceToWorldGeometry(posCounter);

		if (tempDist.x <= distanceEpsilon)
		{
			return getFinalColor(getDiffuse(posCounter, tempDist.y),
								 rayStart, rayDir,
								 posCounter, getNormal(posCounter, tempDist.y),
								 lightDir);
		}
		
		totalDistTraveled += tempDist.x;
		if (totalDistTraveled > maxDist) break;
	}
	
	return fogColor;
}












//--------------------------------------------------------------------
//---------------------Camera data----------------------------
//-----------------------------------------------------------------

struct CameraData { vec3 pos, up, forward, sideways; };
CameraData getCamera()
{
	CameraData dat;

	dat.pos = u_cam_pos + vec3(0.0, 5.0, 0.0);
	dat.forward = u_cam_forward;
	dat.up = u_cam_up;
	dat.sideways = u_cam_side;
	dat.up = normalize(cross(dat.forward, dat.sideways));
	return dat;
}












//--------------------------------------------------------------------
//------------------------Entry point-------------------------------
//-----------------------------------------------------------------

void main(void)
{
	//Map the screen coords to the range (-1, -1) : (1, 1).
	vec2 uv = in_uv_coords;
	uv *= 2.0;
	uv -= vec2(1.0, 1.0);
	
	
	
	//Get camera.
	CameraData camDat = getCamera();
	//Figure out the position of this fragment given the uv, cam pos, and cam direction.
	//Scale the y value using the aspect ratio so that the image isn't stretched.
	vec3 fragStart = (camDat.pos + camDat.forward) +
                     (uv.x * camDat.sideways) +
		             (uv.y * camDat.up * u_resolution.y / u_resolution.x);
	vec3 fragDir = normalize(fragStart - camDat.pos);
	
	
	out_color4 = vec4(marchRay(fragStart, fragDir, camDat.pos), 1.0);
}