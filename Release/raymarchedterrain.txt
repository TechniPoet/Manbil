//	William Manning, 2013
//	A terrain raymarcher. The terrain lies on the XZ plane.





//------------------------------------------------------------------
//--------------------------Noise Generation---------------------------
//-----------------------------------------------------------------

//Generates a random number between 0 and 1.
float rnd(vec2 seed)
{
	return texture2D(u_sampler_0, seed.xy * 2364.23).g;
	//return fract(sin(dot(seed.xy, vec2(12.2342, 12.7025))) * 458.5453);
}
float rnd(float n)
{
    return fract(sin(n)*43758.5453123);
}

//Uses an "ease curve" to push the value of "f" closer to 0 or 1.
//Assumes "f" is between 0 and 1.
float pushToEnds(float f)
{
	return smoothstep(0.0, 1.0, f);
}
vec2 pushToEnds(vec2 v)
{
	return smoothstep(0.0, 1.0, v);
}

float pushToEndsExtreme(float f)
{
	return f * f * f * (10 + (f * (-15 + (6 * f))));
}
float pushToEndsExtreme2(float f)
{
	return pushToEndsExtreme(clamp(f, 0.0, 1.0));
}

//Generate smooth noise at the given scale.
float smoothedNoise(vec2 loc, float scale)
{
	vec2 consts = vec2(scale, 0.0);
	vec2 bottomLeft =  floor(loc / scale) * scale,
		 topLeft = 	   bottomLeft + consts.yx,
	     bottomRight = bottomLeft + consts,
		 topRight =    topLeft    + consts;
	
	float bottomLeftNoise =  rnd(bottomLeft),
		  topLeftNoise =     rnd(topLeft),
		  bottomRightNoise = rnd(bottomRight),
		  topRightNoise =    rnd(topRight);
	
	
	//Get the exact value by getting the weighted average of the noise at the four corners.
	
	//Skewing the interpolants away from the center makes the final result less grid-like.
	vec2 lerpComponents = pushToEnds((loc - bottomLeft) / scale);
	
	//Get the average of the bottom two corners, then the top two corners, then average those averages.
	return mix(mix(bottomLeftNoise, bottomRightNoise, lerpComponents.x),
			   mix(topLeftNoise, topRightNoise, lerpComponents.x),
			   lerpComponents.y);
}

const float startingSize = 5.0,
			startingWeight = 0.5;
const float weightCounterScale = 0.5,
			sizeCounterScale = 0.5;

//Combines multiple layers of smooth noise at different scales.
float fBMNoise(vec2 loc)
{

	loc *= 0.1;

	vec2 x = loc;
	vec2 p = floor(x);
    vec2 f = fract(x);

    f = f*f*(3.0-2.0*f);

    float n = p.x + p.y*57.0;

    float res = mix(mix(rnd(n + 0.0), rnd(n + 1.0), f.x),
                    mix(rnd(n + 57.0), rnd(n+ 58.0), f.x), f.y);
					 
    return res;




	float noise = 0.0,
		  sizeCounter = startingSize,
		  weightCounter = startingWeight;

	for (int i = 0; i < 7; ++i)
	{
		noise = noise + (weightCounter * smoothedNoise(loc, sizeCounter));

		weightCounter *= weightCounterScale;
		sizeCounter *= sizeCounterScale;
	}

	return noise;
}
//Combines the biggest few layers of smooth noise at different scales.
//Coarser noise, but it runs faster.
float lightFBMNoise(vec2 loc)
{
	float noise = 0.0,
	      sizeCounter = startingSize,
		  weightCounter = startingWeight;

	for (int i = 0; i < 3; ++i)
	{
		noise = noise + (weightCounter * smoothedNoise(loc, sizeCounter));

		weightCounter *= weightCounterScale;
		sizeCounter *= sizeCounterScale;
	}

	return noise;
}









//---------------------------------------------------------------
//------------------------Terrain-------------------------------
//-------------------------------------------------------------

//Approximate the normal of the terrain by sampling the terrain's
//    height at several points very near to the actual position.
const float normalApproxIncrement = 0.0001;

const float heightScale = 10.0;

//An unintelligible version of "filterTerrainHeight" written for performance/brevity.
float fastFilterTerrainHeight(float originalHeight)
{
	const float valleyTop = 0.4,
				valleyMid = valleyTop * 0.5,
				valleyQuarter = valleyTop * 0.25,
				valleyThreeQuarter = valleyTop * 0.75;
	
	float isValley = sign(max(0.0, valleyTop - originalHeight));
	return (isValley * mix(originalHeight, valleyMid, clamp(pow(0.88 - (abs(valleyMid - originalHeight) / valleyMid), 0.5), 0.0, 1.0))) +
		   ((1.0 - isValley) * originalHeight);
}

float pushValleyLerp(float f)
{
	return clamp(pow(0.88 - f, 0.5), 0.0, 1.0);
}

//Applies some kind of filter to the height to make it more interesting.
float filterTerrainHeight(float originalHeight)
{
	return fastFilterTerrainHeight(originalHeight);

	//If the terrain here is a valley, smooth it out.

	const float valleyTop = 0.4,
				valleyMid = valleyTop * 0.5,
				valleyQuarter = valleyTop * 0.25,
				valleyThreeQuarter = valleyTop * 0.75;
	
	//This will either be 1.0 (valley) or 0.0 (no valley).
	float isValley = sign(max(0.0, valleyTop - originalHeight));

	//Distance to the center of the valley, from 0.0 (at the center of the valley range)
	//   to 1.0 (at the bottom/top of the valley range).
	float towardsValley = abs(valleyMid - originalHeight) / valleyMid;

	//If this isn't a valley, just return the original height.
	//Otherwise, push the height towards the center of the valley range to smooth it out.
	return (isValley * mix(originalHeight, valleyMid, pushValleyLerp(towardsValley))) +
		   ((1.0 - isValley) * originalHeight);
}

float getTerrainHeight(vec2 terrainPlanePos)
{
	return heightScale * filterTerrainHeight(abs(fBMNoise(terrainPlanePos)));
}
//Gets terrain height using a coarser but faster noise function.
float getLightTerrainHeight(vec2 terrainPlanePos)
{
	return heightScale * filterTerrainHeight(abs(lightFBMNoise(terrainPlanePos)));
}
vec3 estimateTerrainNormal(vec2 terrainPlanePos, float terrainHeight)
{
	vec3 pos = vec3(terrainPlanePos.x, terrainHeight, terrainPlanePos.y);

	vec2 consts = vec2(normalApproxIncrement, 0.0);
	vec3 sampleX = pos + consts.xyy,//vec3(pos.x + normalApproxIncrement, pos.y, pos.z),
		 sampleZ = pos + consts.yyx;//vec3(pos.x, pos.y, pos.z + normalApproxIncrement);
	sampleX.y = getTerrainHeight(sampleX.xz);
	sampleZ.y = getTerrainHeight(sampleZ.xz);

	vec3 ret = normalize(cross(sampleX - pos, sampleZ - pos));

	//if (ret.y > 0.0) ret = -ret;

	return ret;
}








//------------------------------------------------------------------
//--------------------------Terrain Coloring---------------------------
//-----------------------------------------------------------------

vec3 getValleyColor(float heightLerp);
vec3 getMountainColor(float heightLerp);
vec3 getPeakColor(float heightLerp);

//Gets the color of a valley given the given terrain height.
//The terrain height is in the range 0 (bottom of the valley) to 1 (top of the valley).
vec3 getValleyColor(float heightLerp)
{
	return mix(vec3(0.2, 0.4, 0.05),
			   getMountainColor(0.0),
			   pushToEndsExtreme2(heightLerp - 0.35));
}

//Gets the color of a mountain given the terrain height.
//The terrain height is in the range 0 (bottom of the mountain) to 1 (top of the mountain).
vec3 getMountainColor(float heightLerp)
{
	float lerp = 0.5 + (0.5 * sin(heightLerp * 16.0));

	const vec3 col1 = vec3(0.2, 0.1, 0.0),
			   col2 = vec3(0.3, 0.15, 0.0);

	float peakMixAmount = max(0.0, heightLerp - 0.5);
	return mix(mix(col1, col2, lerp),
			   getPeakColor(0.0),
			   peakMixAmount);
}

//Gets the color of a peak given the terrain height.
//The terrain height is in the range 0 (bottom of the peak) to 1 (top of the peak).
vec3 getPeakColor(float heightLerp)
{
	return vec3(1.0, 1.0, 1.0);
}


//Gets the base color of the terrain at a spot given its position and height.
//The height should be from 0 to 1.
vec3 getBaseTerrainColor(vec2 terrainPlanePos, float height)
{
	//Add a bit of randomness to the height for coloring purposes.
	float f = smoothedNoise(terrainPlanePos, 0.25) * pushToEnds(height) * 0.05;
	height = clamp(height + f, 0.0, 1.0);

	//Now choose a color based on the height.
	const float valleyCutoff = 0.3,
				mountainCutoff = 0.81;
	if (height < valleyCutoff)
	{
		return getValleyColor(height / valleyCutoff);
	}
	if (height < mountainCutoff)
	{
		return getMountainColor((height - valleyCutoff) / (mountainCutoff - valleyCutoff));
	}
	
	return getPeakColor((height - mountainCutoff) / (1.0 - mountainCutoff));
}









//----------------------------------------------------------------------
//-------------------------------Lighting--------------------------------
//----------------------------------------------------------------------



//Functions for rotating vectors are needed to make the sun move across the sky.

//Creates a quaternion for rotating vectors around the given axis for the given amount of radians.
vec4 getQuaternion(vec3 axis, float angle)
{
	return vec4(sin(0.5 * angle) * axis,
				cos(0.5 * angle));
}
//Uses a quaternion to rotate a vector.
vec3 rotateVector(vec3 v, vec4 quaternion)
{
	return v + (2.0 * cross(cross(v, quaternion.xyz) + (quaternion.w * v),
							quaternion.xyz));
}


//Uses ambient/diffuse shading, and incorporating a shadow value.

const vec3 baseLightDir = normalize(vec3(1.0, -1.0, 1.0)),
		   lightRotDir = normalize(vec3(1.0, 0.0, -1.0));
const float lightRotSpeed = 0.2;
const float ambientStrength = 0.55,
			diffuseStrength = 0.45;

vec3 getLightDir()
{
	vec3 dir = rotateVector(baseLightDir,
							getQuaternion(lightRotDir, lightRotSpeed * u_elapsed_seconds));

	if (dir.y > 0.0) return -dir;
	return dir;
}
			
//The "shadow" value should be from 0 to one -- 0 meaning entirely covered in shadow, and 1 meaning not covered in shadow.
float getBrightness(vec3 terrNormal, vec2 posOnTerrainPlane, float shadow, vec3 lightDir)
{
	float dotted = max(dot(terrNormal, lightDir), 0.0);

	//The normal way to combine diffuse and ambient is ((dotted * diffuseStrength) + ambientStrength).
	//I played around a LOT with figuring out how to combine ambient/diffuse with a shadow value.
	//I'm not sure if this is actually correct, but it looks nice, so I'm using it.
	return (max(shadow, ambientStrength)) * ((dotted * diffuseStrength) + ambientStrength);
	
	//return clamp((dotted * mix(ambientStrength, diffuseStrength, shadow)), 0.0, 1.0);
}

//Returns a value between 0 and 1 based on how close this ray is to pointing at the sun.
float getSun(vec3 rayDir, vec3 lightDir)
{
	return pushToEnds(pow(0.5 + (0.5 * dot(-lightDir, rayDir)), 128.0));
}








//------------------------------------------------------------------
//--------------------------Fog---------------------------
//-----------------------------------------------------------------

const float fogDropoff = 2.0;
const vec3 fogColor = vec3(0.4, 0.4, 1.0);

float getFog(float distance, float maxPossibleDistance)
{
	return pow(distance / maxPossibleDistance, fogDropoff);
}











//------------------------------------------------------------------
//--------------------------Ray-marching---------------------------
//-----------------------------------------------------------------

const int maxIterations = 500,
		  maxShadowIterations = 200;
const float moveIncrement = 0.05,
			moveIncrementIncrement = 0.0005;
float maxDist = (float(maxIterations) * moveIncrement) + (moveIncrementIncrement * (maxIterations - 1) * maxIterations * 0.5);

vec3 sunColor = vec3(1.0, 1.0, 0.75);

const bool useSoftShadows = false;


//Similar to the main ray-marching algorithm, but this one is used for detecting whether a terrain is cast in shadow.
//Returns a value between 0 and 1 (1 meaning there is no shadow, and 0 meaning the terrain is fully hidden by shadow).
float getShadow(vec3 terrainPos, vec3 lightDir)
{
	vec3 posCounter = terrainPos;
	float totalDistTraveled = moveIncrement;
	float distIncrement = moveIncrement;
	float coarseHeight, fineHeight;

	for (int i = 0; i < maxShadowIterations; ++i)
	{
		posCounter = terrainPos + (-lightDir * totalDistTraveled);

		fineHeight = getTerrainHeight(posCounter.xz);

		if (useSoftShadows)
		{
			coarseHeight = getLightTerrainHeight(posCounter.xz);

			//The terrain pos is in shadow if the light ray passes under the terrain.
			//If the terrain is under the coarse height but not the fine height (or vice-versa),
			//It is near an edge and so it should have a lighter shadow applied to it.
			if (posCounter.y <= coarseHeight)
			{
				if (posCounter.y <= fineHeight)
				{
					return 0.0;
				}
				else
				{
					return 0.65;//clamp(abs(coarseHeight - fineHeight), 0.0, 1.0);
				}
			}
			if (posCounter.y <= fineHeight)
			{
				return 0.65;
			}
		}
		else if (posCounter.y <= fineHeight)
		{
			return 0.0;
		}
		//The terrain pos is not in shadow if it gets above the highest peak of the terrain.
		if (posCounter.y > heightScale)
		{
			return 1.0;
		}

		totalDistTraveled += distIncrement;
		distIncrement += moveIncrementIncrement;
	}

	//Didn't hit the terrain this whole time, so just assume there's no shadow.
	return 1.0;
}



//Calculates the final output color for a point on the terrain,
//    accounting for things like lighting and fog.
vec3 getFinalTerrainColor(vec3 rayStart, vec3 rayDir, vec3 pos, vec3 surfaceNormal, vec3 lightDir)
{
	return mix(getBaseTerrainColor(pos.xz, pos.y / heightScale) *
					getBrightness(surfaceNormal, pos.xz, getShadow(pos, lightDir), lightDir),
			   fogColor,
			   getFog(distance(pos.xz, rayStart.xz),
					  dot(rayDir * maxDist,
						  normalize(vec3(pos.x - rayStart.x, 0.0, pos.z - rayStart.z)))));
}



//Finds where the given ray hits using raymarching.
//Assumes "rayDir" is normalized.
//The return value is the color of the bit of terrain that the ray hit.
vec3 marchRay(vec3 rayStart, vec3 rayDir)
{
	vec3 lightDir = getLightDir();

	vec3 posCounter = rayStart;
	float totalDistTraveled = 0.0;
	bool upwards = (rayDir.y > 0.0);
	float distIncrement = moveIncrement;
	float terrHeight;
	float fog;
	
	for (int i = 0; i < maxIterations; ++i)
	{
		posCounter = rayStart + (rayDir * totalDistTraveled);

		//if (posCounter.y > heightScale && upwards) break;

		terrHeight = getTerrainHeight(posCounter.xz);

		if (posCounter.y <= terrHeight)
		{
			//The real intersection is somewhere between the current ray pos and the previous ray pos.
			posCounter = mix(rayStart + (rayDir * (totalDistTraveled - moveIncrement)),
							 posCounter,
							 0.5);

			posCounter.y = getTerrainHeight(posCounter.xz);
			terrHeight = posCounter.y;

			//Get the final terrain color.
			return getFinalTerrainColor(rayStart, rayDir, posCounter, estimateTerrainNormal(posCounter.xz, terrHeight), lightDir);
		}
		
		totalDistTraveled += distIncrement;
		distIncrement += moveIncrementIncrement;
	}
	
	return mix(fogColor, sunColor, getSun(rayDir, lightDir));
}







//------------------------------------------------------------------
//--------------------------Camera---------------------------
//-----------------------------------------------------------------
struct CameraData { vec3 pos, up, forward, sideways; };
CameraData getCamera()
{
	CameraData dat;

	dat.pos = u_cam_pos;
	dat.pos.y = max(u_cam_pos.y, 2.5 + getTerrainHeight(u_cam_pos.xz));

	dat.forward = u_cam_forward;
	dat.up = u_cam_up;
	dat.sideways = u_cam_side;

	dat.up = normalize(cross(dat.forward, dat.sideways));

	return dat;
}







//------------------------------------------------------------------
//--------------------------Entry point---------------------------
//-----------------------------------------------------------------


void main(void)
{
	//Map the screen coords to the range (-1, -1) : (1, 1).
	vec2 uv = in_uv_coords;
	uv *= 2.0;
	uv -= vec2(1.0, 1.0);
	
	
	
	//Get camera.
	CameraData camDat = getCamera();
	//Figure out the position of this fragment given the uv, cam pos, and cam direction.
	//Scale the y value using the aspect ratio so that the image isn't stretched.
	vec3 fragStart = (camDat.pos + camDat.forward) +
                     (uv.x * camDat.sideways) +
		             (uv.y * camDat.up * u_resolution.y / u_resolution.x);
	vec3 fragDir = normalize(fragStart - camDat.pos);
	
	
	out_color4 = vec4(marchRay(fragStart, fragDir), 1.0);

	//out_color4 = texture2D(u_sampler_0, in_uv_coords);
}