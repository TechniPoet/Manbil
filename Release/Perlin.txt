//Generates a random float for a given vec2.
float rand(vec2 seed)
{
	return fract(sin(dot(seed.xy, vec2(1.051, 16512.9865))) * 458.5453);
}

//With Perlin Noise, every point has to map to two random floats.
float getSecondNoiseVal(vec2 pos)
{
	float noise = rand(pos) + 2623.986;
	return rand(vec2(pos.x + noise, pow(pos.y + noise, 0.9)));
}

//Gets the random vector gradient at the given position.
vec2 getGradient(vec2 pos)
{
	return normalize(vec2(rand(pos), getSecondNoiseVal(pos)));	
}


//Gets the Perlin Noise value for the given position.
//"gridSpace" is the size of one grid cell.
float getNoise(vec2 pos, float gridSpace)
{
	//Get the four grid points surrounding this position.
	vec2 bottomLeft = vec2(floor(pos.x / gridSpace) * gridSpace,
						floor(pos.y / gridSpace) * gridSpace),
		 bottomRight = vec2(bottomLeft.x + gridSpace, bottomLeft.y),
		 topLeft = vec2(bottomLeft.x, bottomLeft.y  + gridSpace),
		 topRight = vec2(bottomRight.x, topLeft.y);
	
	//Get their noise gradients.
	vec2 topLeftN = getGradient(topLeft),
		 topRightN = getGradient(topRight),
		 bottomLeftN = getGradient(bottomLeft),
		 bottomRightN = getGradient(bottomRight);
	
	//Calculate the vector from each grid corner to the postion.
	vec2 deltaTopLeft = pos - topLeft,
		 deltaTopRight = pos - topRight,
		 deltaBottomLeft = pos - bottomLeft,
		 deltaBottomRight = pos - bottomRight;
	
	//Dot each gradient with its corresponding vector to the
	//     position to get that grid element's "influence" on
	//     the noise value.
	float u = dot((deltaTopLeft), topLeftN),
		  v = dot((deltaTopRight), topRightN),
		  s = dot((deltaBottomLeft), bottomLeftN),
		  t = dot((deltaBottomRight), bottomRightN);
	
	//Average the influence of the top two values,
	//   then the influence of the bottom two values,
	//   then average those two averages to get the final noise.
	//Skew these influences to make the noise less grid-like.
	float distX = smoothstep(0.0, 1.0, deltaBottomLeft.x / gridSpace),
		  avgST = mix(s, t, distX),
		  avgUV = mix(u, v, distX),
		  distY = smoothstep(0.0, 1.0, deltaBottomLeft.y / gridSpace),
		  finalAvg = mix(avgST, avgUV, distY);
	return finalAvg;
}

//Outputs Perlin Noise.
void main(void)
{
	//float noise = dot(normalize(vec2(.45, .45)), getGradient(in_uv_coords * u_resolution));
	float noise = getNoise(in_uv_coords * u_resolution, 1.0);
	
	out_color4 = vec4(noise, noise, noise, 500.0);
}